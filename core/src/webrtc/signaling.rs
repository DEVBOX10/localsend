use std::collections::HashMap;
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;
use crate::util::base64;
use anyhow::Result;
use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use serde::{Deserialize, Serialize};
use tokio::sync::{mpsc, Mutex};
use tokio::time::Duration;
#[cfg(feature = "webrtc-signaling")]
use tokio_tungstenite::connect_async;
#[cfg(feature = "webrtc-signaling")]
use tungstenite::{Bytes, Message};
use uuid::Uuid;

/// A message sent by the server to the client.
#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct WsServerMessage {
    #[serde(rename = "type")]
    pub ws_type: WsMessageType,

    /// The list of members (including the client) in the IP room.
    /// Available only for `Hello`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<PeerInfo>>,

    /// The peer that triggered the message.
    /// Available only for `Joined`, `Offer`, and `Answer`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer: Option<PeerInfo>,

    /// The ID of the peer that triggered the message.
    /// Available only for `Left`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer_id: Option<Uuid>,

    /// The session ID of the offer or answer.
    /// Available only for `Offer` and `Answer`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_id: Option<Uuid>,

    /// The SDP string if the message is an offer or answer.
    /// Compressed with Brotli, then encoded with base64 without padding.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sdp: Option<String>,

    /// The error code if the message is an error.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<u16>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum WsMessageType {
    /// The initial message sent to the client that has just connected.
    /// Contains the list of peers in the IP room.
    Hello,

    /// A new peer has joined the IP room.
    /// Broadcasted to all peers.
    Joined,

    /// A peer has left the IP room.
    /// Broadcasted to all peers.
    Left,

    /// SDP offer from a peer to another peer.
    Offer,

    /// SDP answer from a peer to another peer.
    Answer,

    /// Error.
    Error,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PeerInfo {
    /// The ID of the peer. Generated by the server.
    pub id: Uuid,

    /// A fingerprint generated by the client.
    /// Used to merge the same peers detected on different channels (LAN, WebRTC, etc.).
    pub fingerprint: String,

    /// The name of the peer.
    pub alias: String,

    /// The device model of the peer.
    /// Windows, macOS, iPhone, Samsung, etc.
    pub device_model: String,

    /// The device type of the peer.
    pub device_type: PeerDeviceType,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum PeerDeviceType {
    Mobile,
    Desktop,
    Web,
    Headless,
    Server,
}

/// The data that is encoded as JSON which is again encoded as base64.
/// Sent as query during websocket connection.
#[derive(Clone, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PeerInfoWithoutId {
    /// The name of the peer.
    pub alias: String,

    /// A fingerprint generated by the client.
    /// Used to merge the same peers detected on different channels (LAN, WebRTC, etc.).
    pub fingerprint: String,

    /// The device model of the peer.
    /// Windows, macOS, iPhone, Samsung, etc.
    pub device_model: String,

    /// The device type of the peer.
    pub device_type: PeerDeviceType,
}

/// The HTTP request sent by the client to the server.
#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct WsClientMessage {
    #[serde(rename = "type")]
    pub ws_type: WsClientMessageType,

    /// The session id to correctly associate answers with offers.
    /// Generated by the client (the peer that sends the offer).
    pub session_id: Uuid,

    /// Target peer ID.
    pub target: Uuid,

    /// The SDP offer.
    /// Compressed with Brotli, then encoded with base64 without padding.
    pub sdp: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum WsClientMessageType {
    /// SDP offer from a peer to another peer.
    Offer,

    /// SDP answer from a peer to another peer.
    Answer,
}

pub struct SignalingConnection {
    pub tx: mpsc::Sender<WsClientMessage>,
    pub rx: mpsc::Receiver<WsServerMessage>,
}

#[cfg(feature = "webrtc-signaling")]
impl SignalingConnection {
    pub async fn connect<S: Into<String>>(
        uri: S,
        info: &PeerInfoWithoutId,
    ) -> Result<SignalingConnection> {
        let encoded_info = base64::encode(&serde_json::to_string(info)?);
        let uri = format!("{}?d={}", uri.into(), encoded_info);

        tracing::debug!("Connecting to the signaling server at {uri}");

        let (ws_stream, _) = connect_async(&uri).await?;

        tracing::debug!("Connected to the signaling server");

        let (mut write, read) = ws_stream.split();

        let (send_tx, mut send_rx) = mpsc::channel(1);

        tokio::spawn(async move {
            let timeout = Duration::from_secs(120);
            loop {
                let send_result = tokio::time::timeout(timeout, async {
                    if let Some(message) = send_rx.recv().await {
                        let message =
                            serde_json::to_string(&message).expect("Failed to serialize message");
                        if write.send(Message::Text(message.into())).await.is_ok() {
                            return true;
                        }
                    }

                    false
                })
                    .await;

                match send_result {
                    Ok(success) => {
                        if !success {
                            return;
                        }
                    }
                    Err(_) => {
                        // Timeout: send a ping message to keep the connection alive
                        if write.send(Message::Ping(Bytes::new())).await.is_err() {
                            return;
                        }
                    }
                }
            }
        });

        let (receive_tx, receive_rx) = mpsc::channel(1);

        tokio::spawn(async move {
            read.for_each(|message| async {
                if let Ok(Message::Text(message)) = message {
                    match serde_json::from_str::<WsServerMessage>(&message) {
                        Ok(message) => receive_tx.send(message).await.unwrap(),
                        Err(_) => tracing::error!("Server: {message}"),
                    }
                }
            })
                .await;
        });

        Ok(SignalingConnection {
            tx: send_tx,
            rx: receive_rx,
        })
    }

    /// Listen for incoming messages from the server.
    /// Upgrades the API to a higher-level API for
    /// - automatic tracking of peers in the IP room
    /// - exposing callbacks for offers and answers
    pub async fn start_listener(mut self) -> ManagedSignalingConnection {
        let peers: Arc<Mutex<HashMap<Uuid, PeerInfo>>> = Arc::new(Mutex::new(HashMap::new()));
        let on_offer: Arc<Mutex<Option<OfferCallback>>> = Arc::new(Mutex::new(None));
        let on_answer: Arc<Mutex<HashMap<Uuid, AnswerCallback>>> = Arc::new(Mutex::new(HashMap::new()));

        {
            let peers = peers.clone();
            let on_offer = on_offer.clone();
            let on_answer = on_answer.clone();
            tokio::spawn(async move {
                while let Some(message) = self.rx.recv().await {
                    match message.ws_type {
                        WsMessageType::Hello => {
                            if let Some(members) = message.members {
                                for member in members {
                                    peers.lock().await.insert(member.id, member);
                                }
                            }
                        }
                        WsMessageType::Joined => {
                            if let Some(peer) = message.peer {
                                peers.lock().await.insert(peer.id, peer);
                            }
                        }
                        WsMessageType::Left => {
                            if let Some(peer_id) = message.peer_id {
                                peers.lock().await.remove(&peer_id);
                            }
                        }
                        WsMessageType::Offer => {
                            if let Some(callback) = on_offer.lock().await.as_mut() {
                                callback(message);
                            }
                        }
                        WsMessageType::Answer => {
                            if let Some(callback) = on_answer.lock().await.remove(&message.session_id.unwrap()) {
                                callback(message);
                            }
                        }
                        WsMessageType::Error => {
                            tracing::error!("Server error: {:?}", message);
                        }
                    }
                }
            });
        }

        ManagedSignalingConnection {
            tx: self.tx,
            peers,
            on_offer,
            on_answer,
        }
    }

    pub async fn send_offer(
        &self,
        session_id: Uuid,
        target: Uuid,
        sdp: String,
    ) -> Result<()> {
        send_offer(&self.tx, session_id, target, sdp).await?;

        Ok(())
    }

    pub async fn send_answer(
        &self,
        session_id: Uuid,
        target: Uuid,
        sdp: String,
    ) -> Result<()> {
        send_answer(&self.tx, session_id, target, sdp).await?;

        Ok(())
    }
}


type OfferCallback = Box<dyn FnMut(WsServerMessage) + Send + Sync>;
type AnswerCallback = Box<dyn FnOnce(WsServerMessage) + Send + Sync>;

pub struct ManagedSignalingConnection {
    tx: mpsc::Sender<WsClientMessage>,
    peers: Arc<Mutex<HashMap<Uuid, PeerInfo>>>,
    on_offer: Arc<Mutex<Option<OfferCallback>>>,
    on_answer: Arc<Mutex<HashMap<Uuid, AnswerCallback>>>,
}

#[cfg(feature = "webrtc-signaling")]
impl ManagedSignalingConnection {
    pub async fn send_offer(
        &self,
        session_id: Uuid,
        target: Uuid,
        sdp: String,
    ) -> Result<()> {
        send_offer(&self.tx, session_id, target, sdp).await?;

        Ok(())
    }

    pub async fn send_answer(
        &self,
        session_id: Uuid,
        target: Uuid,
        sdp: String,
    ) -> Result<()> {
        send_answer(&self.tx, session_id, target, sdp).await?;

        Ok(())
    }

    /// Adds a callback to be called when an offer is received.
    pub async fn on_offer<F>(&self, callback: F)
    where
        F: FnMut(WsServerMessage) + Send + Sync + 'static,
    {
        let mut on_offer = self.on_offer.lock().await;
        *on_offer = Some(Box::new(callback));
    }

    /// Adds a callback to be called when an answer is received.
    pub async fn on_answer<F>(&self, session_id: Uuid, callback: F)
    where
        F: FnOnce(WsServerMessage) + Send + Sync + 'static,
    {
        let mut callbacks = self.on_answer.lock().await;
        callbacks.insert(session_id, Box::new(callback));
    }
}

async fn send_offer(
    tx: &mpsc::Sender<WsClientMessage>,
    session_id: Uuid,
    target: Uuid,
    sdp: String,
) -> Result<()> {
    tx
        .send(WsClientMessage {
            ws_type: WsClientMessageType::Offer,
            session_id,
            target,
            sdp,
        })
        .await?;

    Ok(())
}

async fn send_answer(
    tx: &mpsc::Sender<WsClientMessage>,
    session_id: Uuid,
    target: Uuid,
    sdp: String,
) -> Result<()> {
    tx
        .send(WsClientMessage {
            ws_type: WsClientMessageType::Answer,
            session_id,
            target,
            sdp,
        })
        .await?;

    Ok(())
}
