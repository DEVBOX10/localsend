use crate::util::base64;
use anyhow::Result;
use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use tokio::time::Duration;
#[cfg(feature = "webrtc-signaling")]
use tokio_tungstenite::connect_async;
#[cfg(feature = "webrtc-signaling")]
use tungstenite::{Bytes, Message};
use uuid::Uuid;

/// A message sent by the server to the client.
#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct WsServerMessage {
    #[serde(rename = "type")]
    pub ws_type: WsMessageType,

    /// The list of members (including the client) in the IP room.
    /// Available only for `Hello` type.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<PeerInfo>>,

    /// The peer that triggered the message.
    /// Available only for `Joined` and `Offer` types.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer: Option<PeerInfo>,

    /// The ID of the peer that triggered the message.
    /// Available only for `Left` and `Answer` types.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer_id: Option<Uuid>,

    /// The SDP string if the message is an offer or answer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sdp: Option<String>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum WsMessageType {
    /// The initial message sent to the client that has just connected.
    /// Contains the list of peers in the IP room.
    Hello,

    /// A new peer has joined the IP room.
    /// Broadcasted to all peers.
    Joined,

    /// A peer has left the IP room.
    /// Broadcasted to all peers.
    Left,

    /// SDP offer from a peer to another peer.
    Offer,

    /// SDP answer from a peer to another peer.
    Answer,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PeerInfo {
    /// The ID of the peer. Generated by the server.
    pub id: Uuid,

    /// A fingerprint generated by the client.
    /// Used to merge the same peers detected on different channels (LAN, WebRTC, etc.).
    pub fingerprint: String,

    /// The name of the peer.
    pub alias: String,

    /// The device model of the peer.
    /// Windows, macOS, iPhone, Samsung, etc.
    pub device_model: String,

    /// The device type of the peer.
    pub device_type: PeerDeviceType,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum PeerDeviceType {
    Mobile,
    Desktop,
    Web,
    Headless,
    Server,
}

/// The data that is encoded as JSON which is again encoded as base64.
/// Sent as query during websocket connection.
#[derive(Clone, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PeerInfoWithoutId {
    /// The name of the peer.
    pub alias: String,

    /// A fingerprint generated by the client.
    /// Used to merge the same peers detected on different channels (LAN, WebRTC, etc).
    pub fingerprint: String,

    /// The device model of the peer.
    /// Windows, macOS, iPhone, Samsung, etc.
    pub device_model: String,

    /// The device type of the peer.
    pub device_type: PeerDeviceType,
}

/// The HTTP request sent by the client to the server.
#[derive(Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SignalingRequestData {
    /// Description of the peer.
    pub info: PeerInfo,

    /// Target peer ID.
    pub target: Uuid,

    /// The SDP offer.
    pub sdp: String,
}

#[cfg(feature = "webrtc-signaling")]
pub async fn connect_and_listen<S: Into<String>>(
    uri: S,
    info: &PeerInfoWithoutId,
) -> Result<mpsc::Receiver<WsServerMessage>> {
    let encoded_info = base64::encode(&serde_json::to_string(info)?);
    let uri = format!("{}?d={}", uri.into(), encoded_info);

    tracing::debug!("Connecting to the signaling server at {uri}");

    let (ws_stream, _) = connect_async(&uri).await?;

    tracing::debug!("Connected to the signaling server");

    let (mut write, read) = ws_stream.split();

    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(120)).await;
            if write.send(Message::Ping(Bytes::new())).await.is_err() {
                break;
            }
        }
    });

    let (tx, rx) = mpsc::channel(1);

    tokio::spawn(async move {
        read.for_each(|message| async {
            if let Ok(Message::Text(message)) = message {
                let message: WsServerMessage = serde_json::from_str(&message).unwrap();
                tx.send(message).await.unwrap();
            }
        })
        .await;
    });

    Ok(rx)
}
