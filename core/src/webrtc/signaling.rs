use crate::util::base64;
use anyhow::Result;
use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use tokio::time::Duration;
#[cfg(feature = "webrtc-signaling")]
use tokio_tungstenite::connect_async;
#[cfg(feature = "webrtc-signaling")]
use tungstenite::{Bytes, Message};
use uuid::Uuid;

/// A message sent by the server to the client.
#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct WsServerMessage {
    #[serde(rename = "type")]
    pub ws_type: WsMessageType,

    /// The list of members (including the client) in the IP room.
    /// Available only for `Hello`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<PeerInfo>>,

    /// The peer that triggered the message.
    /// Available only for `Joined`, `Offer`, and `Answer`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer: Option<PeerInfo>,

    /// The ID of the peer that triggered the message.
    /// Available only for `Left`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer_id: Option<Uuid>,

    /// The SDP string if the message is an offer or answer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sdp: Option<String>,

    /// The error code if the message is an error.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<u16>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum WsMessageType {
    /// The initial message sent to the client that has just connected.
    /// Contains the list of peers in the IP room.
    Hello,

    /// A new peer has joined the IP room.
    /// Broadcasted to all peers.
    Joined,

    /// A peer has left the IP room.
    /// Broadcasted to all peers.
    Left,

    /// SDP offer from a peer to another peer.
    Offer,

    /// SDP answer from a peer to another peer.
    Answer,

    /// Error.
    Error,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PeerInfo {
    /// The ID of the peer. Generated by the server.
    pub id: Uuid,

    /// A fingerprint generated by the client.
    /// Used to merge the same peers detected on different channels (LAN, WebRTC, etc.).
    pub fingerprint: String,

    /// The name of the peer.
    pub alias: String,

    /// The device model of the peer.
    /// Windows, macOS, iPhone, Samsung, etc.
    pub device_model: String,

    /// The device type of the peer.
    pub device_type: PeerDeviceType,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum PeerDeviceType {
    Mobile,
    Desktop,
    Web,
    Headless,
    Server,
}

/// The data that is encoded as JSON which is again encoded as base64.
/// Sent as query during websocket connection.
#[derive(Clone, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PeerInfoWithoutId {
    /// The name of the peer.
    pub alias: String,

    /// A fingerprint generated by the client.
    /// Used to merge the same peers detected on different channels (LAN, WebRTC, etc.).
    pub fingerprint: String,

    /// The device model of the peer.
    /// Windows, macOS, iPhone, Samsung, etc.
    pub device_model: String,

    /// The device type of the peer.
    pub device_type: PeerDeviceType,
}

/// The HTTP request sent by the client to the server.
#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct WsClientMessage {
    #[serde(rename = "type")]
    pub ws_type: WsClientMessageType,

    /// Target peer ID.
    pub target: Uuid,

    /// The SDP offer.
    pub sdp: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum WsClientMessageType {
    /// SDP offer from a peer to another peer.
    Offer,

    /// SDP answer from a peer to another peer.
    Answer,
}

pub struct SignalingConnection {
    pub tx: mpsc::Sender<WsClientMessage>,
    pub rx: mpsc::Receiver<WsServerMessage>,
}

#[cfg(feature = "webrtc-signaling")]
pub async fn connect_and_listen<S: Into<String>>(
    uri: S,
    info: &PeerInfoWithoutId,
) -> Result<SignalingConnection> {
    let encoded_info = base64::encode(&serde_json::to_string(info)?);
    let uri = format!("{}?d={}", uri.into(), encoded_info);

    tracing::debug!("Connecting to the signaling server at {uri}");

    let (ws_stream, _) = connect_async(&uri).await?;

    tracing::debug!("Connected to the signaling server");

    let (mut write, read) = ws_stream.split();

    let (send_tx, mut send_rx) = mpsc::channel(1);

    tokio::spawn(async move {
        let timeout = Duration::from_secs(120);
        loop {
            let send_result = tokio::time::timeout(timeout, async {
                if let Some(message) = send_rx.recv().await {
                    let message =
                        serde_json::to_string(&message).expect("Failed to serialize message");
                    if write.send(Message::Text(message.into())).await.is_ok() {
                        return true;
                    }
                }

                false
            })
            .await;

            match send_result {
                Ok(success) => {
                    if !success {
                        return;
                    }
                }
                Err(_) => {
                    // Timeout: send a ping message to keep the connection alive
                    if write.send(Message::Ping(Bytes::new())).await.is_err() {
                        return;
                    }
                }
            }
        }
    });

    let (receive_tx, receive_rx) = mpsc::channel(1);

    tokio::spawn(async move {
        read.for_each(|message| async {
            if let Ok(Message::Text(message)) = message {
                match serde_json::from_str::<WsServerMessage>(&message) {
                    Ok(message) => receive_tx.send(message).await.unwrap(),
                    Err(_) => tracing::error!("Server: {message}"),
                }
            }
        })
        .await;
    });

    Ok(SignalingConnection {
        tx: send_tx,
        rx: receive_rx,
    })
}

#[cfg(feature = "webrtc-signaling")]
pub async fn send_offer(connection: SignalingConnection, target: Uuid, sdp: String) -> Result<()> {
    connection
        .tx
        .send(WsClientMessage {
            ws_type: WsClientMessageType::Offer,
            target,
            sdp,
        })
        .await?;

    Ok(())
}

#[cfg(feature = "webrtc-signaling")]
pub async fn send_answer(connection: SignalingConnection, target: Uuid, sdp: String) -> Result<()> {
    connection
        .tx
        .send(WsClientMessage {
            ws_type: WsClientMessageType::Answer,
            target,
            sdp,
        })
        .await?;

    Ok(())
}
